{% extends "base.html" %}

{% block title %}My Bets{% endblock %}

{% block content %}
<div class="page-wrapper">
  <div class="page-header d-print-none">
    <div class="container-xl">
      <div class="row g-2 align-items-center">
        <div class="col">
          <h2 class="page-title">
            <i class="ti ti-coins icon me-2"></i>
            My Bets
          </h2>
          <div class="text-muted mt-1">
            Track your betting performance and P&L
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="page-body">
    <div class="container-xl">
      
      <!-- Summary Cards -->
      {% if summary %}
      <div class="row row-deck row-cards mb-4">
        <div class="col-sm-6 col-lg-3">
          <div class="card">
            <div class="card-body">
              <div class="subheader">Total Profit/Loss</div>
              <div class="h1 mb-3">
                <span class="{% if summary.total_profit >= 0 %}text-success{% else %}text-danger{% endif %}">
                  ${{ "%.2f"|format(summary.total_profit) }}
                </span>
              </div>
            </div>
          </div>
        </div>
        <div class="col-sm-6 col-lg-3">
          <div class="card">
            <div class="card-body">
              <div class="subheader">Total Wagered</div>
              <div class="h1 mb-3">${{ "%.2f"|format(summary.total_amount) }}</div>
            </div>
          </div>
        </div>
        <div class="col-sm-6 col-lg-3">
          <div class="card">
            <div class="card-body">
              <div class="subheader">Pending Bets</div>
              <div class="h1 mb-3">{{ summary.pending_count }} <span class="text-muted">(${{ "%.2f"|format(summary.pending_amount) }})</span></div>
            </div>
          </div>
        </div>
        <div class="col-sm-6 col-lg-3">
          <div class="card">
            <div class="card-body">
              <div class="subheader">Potential Win</div>
              <div class="h1 mb-3 text-success">${{ "%.2f"|format(summary.potential_win) }}</div>
            </div>
          </div>
        </div>
      </div>
      {% endif %}

      <!-- Bets Table -->
      {% if bets %}
      <div class="row">
        <div class="col-12">
          <div class="card">
            <div class="card-header">
              <h3 class="card-title">
                <i class="ti ti-list icon me-2"></i>
                Your Bets ({{ bets|length }})
              </h3>
              <div class="card-actions">
                <button class="btn btn-primary me-2" onclick="autoGradeAllBets()" id="autoGradeBtn">
                  <i class="ti ti-robot icon"></i>
                  Auto-Grade All Bets
                </button>
                <div class="input-group input-group-flat">
                  <input type="text" class="form-control" id="searchInput" placeholder="Search bets..." onkeyup="filterTable()">
                  <span class="input-group-text">
                    <i class="ti ti-search icon"></i>
                  </span>
                </div>
              </div>
            </div>
            <div class="card-body p-0">
              <!-- Filters -->
              <div class="p-3 border-bottom">
                <div class="row g-2">
                  <div class="col-md-3">
                    <select class="form-select" id="filterType" onchange="filterTable()">
                      <option value="">All Types</option>
                      <option value="Spread">Spread</option>
                      <option value="Parlay">Parlay</option>
                      <option value="Same Game Parlay">Same Game Parlay</option>
                      <option value="Live">Live</option>
                    </select>
                  </div>
                  <div class="col-md-3">
                    <select class="form-select" id="filterStatus" onchange="filterTable()">
                      <option value="">All Status</option>
                      <option value="Pending">Pending</option>
                      <option value="Won">Won</option>
                      <option value="Lost">Lost</option>
                    </select>
                  </div>
                  <div class="col-md-3">
                    <input type="date" class="form-control" id="filterDateFrom" onchange="filterTable()" placeholder="From Date">
                  </div>
                  <div class="col-md-3">
                    <input type="date" class="form-control" id="filterDateTo" onchange="filterTable()" placeholder="To Date">
                  </div>
                </div>
              </div>
              
              <!-- Table -->
              <div class="table-responsive">
                <style>
                  #betsTable tbody tr:hover {
                    background-color: var(--tblr-hover-bg);
                    transform: scale(1.001);
                    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
                  }
                </style>
                <table class="table table-vcenter card-table table-striped" id="betsTable">
                  <thead>
                    <tr>
                      <th class="w-1">Ticket #</th>
                      <th>Date</th>
                      <th>Description</th>
                      <th>Type</th>
                      <th>Status</th>
                      <th class="text-end">Amount</th>
                      <th class="text-end">To Win</th>
                      <th class="text-end">Profit</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for bet in bets %}
                    <tr data-type="{{ bet.type }}" data-status="{{ bet.status }}" data-date="{{ bet.date }}" 
                        style="cursor: pointer;" 
                        onclick='showBetDetails({{ bet|tojson }})'>
                      <td class="text-muted">
                        <small class="font-monospace">{{ bet.ticket_id }}</small>
                      </td>
                      <td>{{ bet.date }}</td>
                      <td>
                        <div class="text-truncate" style="max-width: 400px;" title="{{ bet.description }}">
                          {{ bet.description }}
                        </div>
                      </td>
                      <td>
                        <span class="badge bg-blue-lt">{{ bet.type }}</span>
                      </td>
                      <td>
                        {% if bet.status == 'Pending' %}
                          <span class="badge bg-yellow-lt">Pending</span>
                        {% elif bet.status == 'Won' %}
                          <span class="badge bg-success-lt">Won</span>
                        {% elif bet.status == 'Lost' %}
                          <span class="badge bg-danger-lt">Lost</span>
                        {% else %}
                          <span class="badge bg-secondary-lt">{{ bet.status }}</span>
                        {% endif %}
                      </td>
                      <td class="text-end">${{ "%.2f"|format(bet.amount) }}</td>
                      <td class="text-end">
                        {% if bet.to_win > 0 %}
                          <span class="text-success">${{ "%.2f"|format(bet.to_win) }}</span>
                        {% else %}
                          <span class="text-muted">-</span>
                        {% endif %}
                      </td>
                      <td class="text-end">
                        {% if bet.profit > 0 %}
                          <span class="text-success fw-bold">+${{ "%.2f"|format(bet.profit) }}</span>
                        {% elif bet.profit < 0 %}
                          <span class="text-danger fw-bold">-${{ "%.2f"|format(bet.profit|abs) }}</span>
                        {% else %}
                          <span class="text-muted">-</span>
                        {% endif %}
                      </td>
                    </tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
      {% else %}
      <div class="row">
        <div class="col-12">
          <div class="card">
            <div class="card-body text-center py-5">
              <div class="empty">
                <div class="empty-icon">
                  <i class="ti ti-clipboard-off icon" style="font-size: 4rem;"></i>
                </div>
                <p class="empty-title">No bets loaded yet</p>
                <p class="empty-subtitle text-muted">
                  Paste your bet data above to get started
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
      {% endif %}

      <!-- Paste Bets Interface -->
      <div class="row mt-4">
        <div class="col-12">
          <div class="card">
            <div class="card-header">
              <h3 class="card-title">
                <i class="ti ti-clipboard icon me-2"></i>
                Paste Your Bets from BetOnline
              </h3>
            </div>
            <div class="card-body">
              <div class="alert alert-info">
                <h4 class="alert-title">üìã How to Add Your Bets:</h4>
                <p class="mb-2"><strong>BetOnline blocks API access, so just copy/paste your bet data:</strong></p>
                <ol class="mb-0">
                  <li>Go to BetOnline ‚Üí My Account ‚Üí Bet History</li>
                  <li>Select and copy the entire bet table (Ctrl+A, Ctrl+C)</li>
                  <li>Paste it in the box below</li>
                  <li>Click "Load Bets"</li>
                </ol>
                <p class="mt-2 mb-0"><small class="text-muted">For parlays, separate legs with | (pipe). Example: <code>Cowboys +3.5 | Patriots ML | Over 45.5</code></small></p>
              </div>
              
              <div class="mb-3">
                <label class="form-label">Paste your bet data here:</label>
                <textarea class="form-control font-monospace" id="betDataInput" rows="10" placeholder="Paste your BetOnline bet table data here...

Format (one bet per line):
TicketID | Date | Description | Type | Status | Amount | ToWin

For parlays with multiple legs:
TicketID | Date | Team1 +3.5 | Team2 ML | Over 45.5 | Parlay | Pending | 10.00 | 50.00"></textarea>
              </div>
              
              <button class="btn btn-primary btn-lg" onclick="loadBets()">
                <i class="ti ti-upload icon me-2"></i>
                Load Bets
              </button>
              
              <button class="btn btn-ghost-secondary ms-2" onclick="clearBets()">
                <i class="ti ti-trash icon me-2"></i>
                Clear All
              </button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- Bet Details Modal -->
<div class="modal modal-blur fade" id="betDetailsModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">
          <i class="ti ti-ticket icon me-2"></i>
          Bet Details
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row mb-3">
          <div class="col-md-6">
            <div class="mb-3">
              <label class="form-label text-muted">Ticket Number</label>
              <div class="h3 font-monospace" id="modalTicketId"></div>
            </div>
          </div>
          <div class="col-md-6">
            <div class="mb-3">
              <label class="form-label text-muted">Date</label>
              <div class="h3" id="modalDate"></div>
            </div>
          </div>
        </div>
        
        <div class="mb-3">
          <label class="form-label text-muted">Bet Details</label>
          <div class="card">
            <div class="card-body">
              <div id="modalDescription"></div>
            </div>
          </div>
        </div>
        
        <div class="row mb-3">
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label text-muted">Type</label>
              <div id="modalType"></div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label text-muted">Status</label>
              <div id="modalStatus"></div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="mb-3">
              <label class="form-label text-muted">Odds</label>
              <div class="h3" id="modalOdds">-</div>
            </div>
          </div>
        </div>
        
        <hr>
        
        <div class="row">
          <div class="col-md-4">
            <div class="card bg-blue-lt">
              <div class="card-body text-center">
                <div class="text-muted mb-1">Amount Wagered</div>
                <div class="h2 mb-0" id="modalAmount"></div>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="card bg-success-lt">
              <div class="card-body text-center">
                <div class="text-muted mb-1">To Win</div>
                <div class="h2 mb-0" id="modalToWin"></div>
              </div>
            </div>
          </div>
          <div class="col-md-4">
            <div class="card" id="modalProfitCard">
              <div class="card-body text-center">
                <div class="text-muted mb-1">Profit/Loss</div>
                <div class="h2 mb-0" id="modalProfit"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="row mt-3">
          <div class="col-12">
            <div class="card bg-muted-lt">
              <div class="card-body">
                <div class="row">
                  <div class="col-md-6">
                    <div class="text-muted mb-1">Return on Investment</div>
                    <div class="h3 mb-0" id="modalROI"></div>
                  </div>
                  <div class="col-md-6">
                    <div class="text-muted mb-1">Potential ROI</div>
                    <div class="h3 mb-0" id="modalPotentialROI"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <div class="d-flex justify-content-between w-100">
          <div>
            <button type="button" class="btn btn-success" onclick="updateBetStatus('Won')">
              <i class="ti ti-check icon"></i> Mark as Won
            </button>
            <button type="button" class="btn btn-danger" onclick="updateBetStatus('Lost')">
              <i class="ti ti-x icon"></i> Mark as Lost
            </button>
            <button type="button" class="btn btn-warning" onclick="updateBetStatus('Pending')">
              <i class="ti ti-clock icon"></i> Mark as Pending
            </button>
          </div>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// Store current bet being viewed
let currentBetTicketId = null;

// Parse parlay legs from description
function parseParlayLegs(description) {
  // Handle format 1: "12-team parlay: CAR +7, NYG +7.5, MIA +7.5, ..."
  const shortMatch = description.match(/parlay:\s*(.+)/i);
  if (shortMatch) {
    const legsStr = shortMatch[1];
    // Check if it uses pipe separator or comma separator
    if (legsStr.includes(' | ')) {
      return legsStr.split(' | ').map(leg => leg.trim());
    } else {
      return legsStr.split(',').map(leg => leg.trim());
    }
  }
  
  // Handle format 2: Raw BetOnline format with pipes
  // "FOOTBALL - NFL - ... | Money line - Colts (Game) | Player stats - Daniel Jones over 211.5 Passing yds (Game)"
  // OR concatenated format: "...PendingFootball - NFL - Dallas Cowboys vs Denver Broncos - Parlay | 279 Dallas Cowboys +3¬Ω..."
  if (description.includes('Football - NFL -')) {
    const legs = [];
    
    // Split by "Football - NFL -" to get individual games
    const games = description.split(/Football - NFL -/i).filter(g => g.trim().length > 0);
    
    for (const game of games) {
      // Each game contains: "Team1 vs Team2 - Parlay | number Team +spread odds For Game | date | time | status"
      // Extract the bet line (the part with the number, team, spread, odds)
      const betMatch = game.match(/\|\s*\d+\s+(.+?)\s+([-+]\d+(?:¬Ω)?|over|under)\s+([\d.]+)?\s*[-+]?\d+\s+For\s+Game/i);
      if (betMatch) {
        const teamOrTotal = betMatch[1].trim();
        const lineType = betMatch[2];
        const lineValue = betMatch[3];
        
        // Check if it's a total (over/under)
        if (lineType.toLowerCase() === 'over' || lineType.toLowerCase() === 'under') {
          // It's a total: "Green Bay Packers/Pittsburgh Steelers over 46"
          legs.push(`${teamOrTotal.replace(/\//g, '/')} ${lineType} ${lineValue}`);
        } else {
          // It's a spread: "Dallas Cowboys +3¬Ω"
          legs.push(`${teamOrTotal} ${lineType.replace('¬Ω', '.5')}`);
        }
      }
    }
    
    return legs;
  }
  
  // Handle format 3: Line-by-line format with pipes
  // Return FULL leg descriptions so getLegLiveStatus can properly detect player props
  if (description.includes('FOOTBALL - NFL -') || description.includes('Money line -') || description.includes('Player stats -')) {
    const legs = [];
    const parts = description.split(' | ');
    
    for (const part of parts) {
      // Skip the game header
      if (part.includes('FOOTBALL - NFL -')) continue;
      
      // Keep the FULL description for each leg so getLegLiveStatus can parse it
      if (part.includes('Money line -') || part.includes('Player stats -') || part.includes('Spread -') || part.includes('Total points -')) {
        legs.push(part.trim());
      }
    }
    
    return legs;
  }
  
  return [];
}

// Get live status for a parlay leg
async function getLegLiveStatus(leg, liveGames) {
  // Check if it's a player prop
  // Format: "Player stats - Daniel Jones 2+ Passing TDs thrown (Game)"
  if (leg.includes('Player stats -') || leg.includes('player stats -')) {
    // For player props, we need to call the backend API
    // Try each live game until we find one that has stats for this prop
    for (const game of liveGames) {
      if (game && game.id) {
        try {
          const response = await fetch(`/api/check-player-prop?game_id=${game.id}&prop=${encodeURIComponent(leg)}`);
          const data = await response.json();
          
          // If we got a status (not null), this is the right game
          if (data.status) {
            return {
              status: data.status,
              game: game
            };
          }
        } catch (error) {
          console.error('Error checking player prop:', error);
        }
      }
    }
    
    // No game found with this player
    return {
      status: 'neutral',
      game: null
    };
  }
  
  // Check if it's a moneyline
  // Format: "Money line - Colts (Game)"
  const mlMatch = leg.match(/Money line - (\w+)/i);
  if (mlMatch) {
    const teamName = mlMatch[1].trim();
    
    // Find matching game
    for (const game of liveGames) {
      if (game.home_team.includes(teamName) || game.away_team.includes(teamName) ||
          game.home_abbr === teamName || game.away_abbr === teamName) {
        const isHome = game.home_team.includes(teamName) || game.home_abbr === teamName;
        
        let status;
        if (isHome) {
          if (game.home_score > game.away_score) {
            status = 'winning';
          } else if (game.home_score < game.away_score) {
            status = 'losing';
          } else {
            status = 'neutral';
          }
        } else {
          if (game.away_score > game.home_score) {
            status = 'winning';
          } else if (game.away_score < game.home_score) {
            status = 'losing';
          } else {
            status = 'neutral';
          }
        }
        
        return {
          status: status,
          game: game
        };
      }
    }
    
    return null;
  }
  
  // Check if it's a total (over/under)
  // Format: "Green Bay Packers/Pittsburgh Steelers over 46"
  const totalMatch = leg.match(/(.+?)\/(.*?)\s+(over|under)\s+([\d.]+)/i);
  if (totalMatch) {
    const team1 = totalMatch[1].trim();
    const team2 = totalMatch[2].trim();
    const overUnder = totalMatch[3].toLowerCase();
    const line = parseFloat(totalMatch[4]);
    
    // Find matching game by team names
    for (const game of liveGames) {
      if ((game.home_team.includes(team1) || game.away_team.includes(team1)) &&
          (game.home_team.includes(team2) || game.away_team.includes(team2))) {
        const currentTotal = game.home_score + game.away_score;
        
        let status;
        if (overUnder === 'over') {
          if (currentTotal > line) {
            status = 'winning';
          } else if (currentTotal < line * 0.8) {
            status = 'losing';
          } else {
            status = 'neutral';
          }
        } else { // under
          if (currentTotal < line) {
            status = 'winning';
          } else if (currentTotal > line * 0.8) {
            status = 'losing';
          } else {
            status = 'neutral';
          }
        }
        
        return {
          status: status,
          game: game
        };
      }
    }
    
    return null; // Game not live yet
  }
  
  // Parse spread leg like "CAR +7" or "MIA +7.5" or "Dallas Cowboys +3.5"
  const spreadMatch = leg.match(/(.+?)\s+([-+]\d+(?:\.\d+)?)/);
  if (!spreadMatch) return null;
  
  const teamName = spreadMatch[1].trim();
  const spread = parseFloat(spreadMatch[2]);
  
  // Find matching live game by team name or abbreviation
  for (const game of liveGames) {
    if (game.away_abbr === teamName || game.home_abbr === teamName ||
        game.away_team.includes(teamName) || game.home_team.includes(teamName)) {
      // Determine if this leg is winning
      let scoreDiff;
      if (game.away_abbr === teamName || game.away_team.includes(teamName)) {
        // Betting on away team
        scoreDiff = game.away_score - game.home_score;
      } else {
        // Betting on home team
        scoreDiff = game.home_score - game.away_score;
      }
      
      const effectiveDiff = scoreDiff + spread;
      
      let status;
      if (effectiveDiff > 0) {
        status = 'winning';
      } else if (effectiveDiff < 0) {
        status = 'losing';
      } else {
        status = 'neutral';
      }
      
      return {
        status: status,
        game: game
      };
    }
  }
  
  return null; // Game not live yet
}

// Parse bet description into structured HTML
function parseDescription(description, betType) {
  // Check if it's a parlay with multiple legs (contains pipe separator)
  if (description.includes(' | ')) {
    // Split by " | " to get individual legs
    const legs = description.split(' | ').map(leg => leg.trim()).filter(leg => leg.length > 0);
    
    if (legs.length > 1) {
      let html = '<div class="list-group list-group-flush">';
      legs.forEach((leg, index) => {
        // Extract odds if present (e.g., "+3¬Ω -118" or "over 46 -110")
        const oddsMatch = leg.match(/([-+]\d+(?:¬Ω)?)\s+([-+]\d+)/);
        let displayLeg = leg;
        let odds = '';
        
        if (oddsMatch) {
          odds = `<span class="badge bg-success-lt ms-2">${oddsMatch[2]}</span>`;
        }
        
        html += `
          <div class="list-group-item">
            <div class="row align-items-center">
              <div class="col-auto">
                <span class="badge bg-blue text-white">${index + 1}</span>
              </div>
              <div class="col">
                <div class="d-flex align-items-center justify-content-between">
                  <span><strong>${displayLeg}</strong></span>
                  ${odds}
                </div>
              </div>
            </div>
          </div>
        `;
      });
      html += '</div>';
      
      // Add summary
      html += `<div class="mt-3"><span class="badge bg-blue-lt">${legs.length} legs</span> in this ${betType}</div>`;
      
      return html;
    }
  }
  
  // Single bet or simple description - just display it
  return `<p class="mb-0">${description}</p>`;
}

// Show bet details in modal
async function showBetDetails(bet) {
  // Store current bet ticket ID for status updates
  currentBetTicketId = bet.ticket_id;
  
  // Populate modal fields
  document.getElementById('modalTicketId').textContent = bet.ticket_id;
  document.getElementById('modalDate').textContent = bet.date;
  
  // Parse and display description
  const descEl = document.getElementById('modalDescription');
  
  // Special handling for Round Robin bets with sub_bets
  if (bet.type === 'Round Robin' && bet.sub_bets && bet.sub_bets.length > 0) {
    let html = '<div class="alert alert-info mb-3">';
    html += '<i class="ti ti-info-circle icon me-2"></i>';
    html += `This Round Robin contains <strong>${bet.sub_bets.length} combinations</strong>`;
    html += '</div>';
    
    html += '<div class="list-group list-group-flush">';
    bet.sub_bets.forEach((subBet, index) => {
      const statusClass = subBet.status === 'Won' ? 'success' : (subBet.status === 'Lost' ? 'danger' : 'warning');
      html += `
        <div class="list-group-item">
          <div class="row align-items-center">
            <div class="col-auto">
              <span class="badge bg-${statusClass} text-white">#${index + 1}</span>
            </div>
            <div class="col">
              <div class="mb-1"><small class="text-muted">${subBet.ticket_id}</small></div>
              <div class="text-truncate" style="max-width: 500px;" title="${subBet.description}">
                ${subBet.description}
              </div>
            </div>
            <div class="col-auto text-end">
              <div class="text-muted small">Stake: $${parseFloat(subBet.amount).toFixed(2)}</div>
              <div class="text-success small">Win: $${parseFloat(subBet.to_win).toFixed(2)}</div>
            </div>
          </div>
        </div>
      `;
    });
    html += '</div>';
    
    descEl.innerHTML = html;
  } else if (bet.type.toLowerCase().includes('parlay') && bet.status === 'Pending') {
    // For parlays, fetch live data and show each leg with colors
    descEl.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm" role="status"></div> Loading live data...</div>';
    
    try {
      const liveData = await fetch('/api/live-games').then(r => r.json());
      const legs = parseParlayLegs(bet.description);
      
      let html = '<div class="list-group list-group-flush">';
      
      // Use for...of instead of forEach so we can await
      for (let index = 0; index < legs.length; index++) {
        const leg = legs[index];
        const legStatus = await getLegLiveStatus(leg, liveData);
        let listItemClass = '';
        let badgeClass = 'bg-secondary';
        let statusIcon = '‚ö™';
        let statusText = 'Not Started';
        let scoreText = '';
        
        if (legStatus) {
          if (legStatus.status === 'winning') {
            listItemClass = 'list-group-item-success';
            badgeClass = 'bg-success';
            statusIcon = 'üü¢';
            statusText = 'WINNING';
          } else if (legStatus.status === 'losing') {
            listItemClass = 'list-group-item-danger';
            badgeClass = 'bg-danger';
            statusIcon = 'üî¥';
            statusText = 'LOSING';
          } else if (legStatus.status === 'neutral') {
            listItemClass = 'list-group-item-warning';
            badgeClass = 'bg-warning';
            statusIcon = 'üü°';
            statusText = 'PUSH';
          }
          
          if (legStatus.game) {
            scoreText = `<small class="text-muted ms-2">${legStatus.game.away_score}-${legStatus.game.home_score}</small>`;
          }
        }
        
        html += `
          <div class="list-group-item ${listItemClass}">
            <div class="row align-items-center">
              <div class="col-auto">
                <span class="badge bg-blue text-white">${index + 1}</span>
              </div>
              <div class="col">
                <div class="d-flex align-items-center justify-content-between">
                  <span><strong>${leg}</strong> ${scoreText}</span>
                  <span class="badge ${badgeClass} text-white">${statusIcon} ${statusText}</span>
                </div>
              </div>
            </div>
          </div>
        `;
      }
      
      html += '</div>';
      html += `<div class="mt-3"><span class="badge bg-blue-lt">${legs.length} legs</span> in this ${bet.type}</div>`;
      
      descEl.innerHTML = html;
    } catch (error) {
      console.error('Error fetching live data:', error);
      descEl.innerHTML = parseDescription(bet.description, bet.type);
    }
  } else {
    // Regular bet - parse description normally
    descEl.innerHTML = parseDescription(bet.description, bet.type);
  }
  
  // Type badge
  document.getElementById('modalType').innerHTML = `<span class="badge bg-blue-lt">${bet.type}</span>`;
  
  // Status badge
  let statusBadge = '';
  if (bet.status === 'Pending') {
    statusBadge = '<span class="badge bg-yellow-lt">Pending</span>';
  } else if (bet.status === 'Won') {
    statusBadge = '<span class="badge bg-success-lt">Won</span>';
  } else if (bet.status === 'Lost') {
    statusBadge = '<span class="badge bg-danger-lt">Lost</span>';
  } else {
    statusBadge = `<span class="badge bg-secondary-lt">${bet.status}</span>`;
  }
  document.getElementById('modalStatus').innerHTML = statusBadge;
  
  // Financial details
  const amount = parseFloat(bet.amount) || 0;
  const toWin = parseFloat(bet.to_win) || 0;
  document.getElementById('modalAmount').textContent = '$' + amount.toFixed(2);
  document.getElementById('modalToWin').textContent = toWin > 0 ? '$' + toWin.toFixed(2) : '-';
  
  // Profit/Loss with color
  const profitCard = document.getElementById('modalProfitCard');
  const profitEl = document.getElementById('modalProfit');
  const profit = parseFloat(bet.profit) || 0;
  
  if (profit > 0) {
    profitCard.className = 'card bg-success-lt';
    profitEl.innerHTML = '<span class="text-success">+$' + profit.toFixed(2) + '</span>';
  } else if (profit < 0) {
    profitCard.className = 'card bg-danger-lt';
    profitEl.innerHTML = '<span class="text-danger">-$' + Math.abs(profit).toFixed(2) + '</span>';
  } else {
    profitCard.className = 'card bg-muted-lt';
    profitEl.textContent = '-';
  }
  
  // Calculate ROI
  const roi = amount > 0 ? (profit / amount * 100) : 0;
  const potentialRoi = amount > 0 && toWin > 0 ? (toWin / amount * 100) : 0;
  
  const roiEl = document.getElementById('modalROI');
  if (bet.status === 'Won') {
    roiEl.innerHTML = '<span class="text-success">+' + roi.toFixed(1) + '%</span>';
  } else if (bet.status === 'Lost') {
    roiEl.innerHTML = '<span class="text-danger">' + roi.toFixed(1) + '%</span>';
  } else {
    roiEl.textContent = '-';
  }
  
  const potentialRoiEl = document.getElementById('modalPotentialROI');
  if (bet.status === 'Pending' && bet.to_win > 0) {
    potentialRoiEl.innerHTML = '<span class="text-success">+' + potentialRoi.toFixed(1) + '%</span>';
  } else {
    potentialRoiEl.textContent = '-';
  }
  
  // Calculate and display odds (if we can extract from description)
  const oddsMatch = bet.description.match(/[-+]\d+/);
  if (oddsMatch) {
    document.getElementById('modalOdds').textContent = oddsMatch[0];
  } else {
    document.getElementById('modalOdds').textContent = '-';
  }
  
  // Show modal using Bootstrap
  const modal = new bootstrap.Modal(document.getElementById('betDetailsModal'));
  modal.show();
}

// Update bet status (Won/Lost/Pending)
async function updateBetStatus(newStatus) {
  if (!currentBetTicketId) {
    alert('Error: No bet selected');
    return;
  }
  
  try {
    const response = await fetch('/api/bets/update-status', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        ticket_id: currentBetTicketId,
        status: newStatus
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('betDetailsModal'));
      modal.hide();
      
      // Reload page to show updated status
      location.reload();
    } else {
      alert('Error updating bet: ' + result.message);
    }
  } catch (error) {
    console.error('Error updating bet status:', error);
    alert('Failed to update bet status');
  }
}

// Auto-grade all pending bets based on live scores
async function autoGradeAllBets() {
  const btn = document.getElementById('autoGradeBtn');
  const originalText = btn.innerHTML;
  
  if (!confirm('Auto-grade all pending bets based on live scores?\n\nThis will mark completed games as Won/Lost automatically.')) {
    return;
  }
  
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Grading...';
  
  try {
    const response = await fetch('/api/bets/auto-grade', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    const result = await response.json();
    
    if (result.success) {
      alert(`‚úÖ Auto-grading complete!\n\n` +
            `Graded: ${result.graded} bets\n` +
            `Won: ${result.won}\n` +
            `Lost: ${result.lost}\n` +
            `Still Pending: ${result.still_pending}`);
      location.reload();
    } else {
      alert('Error: ' + result.message);
      btn.disabled = false;
      btn.innerHTML = originalText;
    }
  } catch (error) {
    console.error('Error auto-grading bets:', error);
    alert('Failed to auto-grade bets');
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
}

// Filter table function
function filterTable() {
  const searchInput = document.getElementById('searchInput').value.toLowerCase();
  const filterType = document.getElementById('filterType').value;
  const filterStatus = document.getElementById('filterStatus').value;
  const filterDateFrom = document.getElementById('filterDateFrom').value;
  const filterDateTo = document.getElementById('filterDateTo').value;
  
  const table = document.getElementById('betsTable');
  const rows = table.getElementsByTagName('tr');
  
  for (let i = 1; i < rows.length; i++) {
    const row = rows[i];
    const type = row.getAttribute('data-type');
    const status = row.getAttribute('data-status');
    const date = row.getAttribute('data-date');
    const text = row.textContent.toLowerCase();
    
    let show = true;
    
    // Search filter
    if (searchInput && !text.includes(searchInput)) {
      show = false;
    }
    
    // Type filter
    if (filterType && type !== filterType) {
      show = false;
    }
    
    // Status filter
    if (filterStatus && status !== filterStatus) {
      show = false;
    }
    
    // Date range filter
    if (filterDateFrom && date < filterDateFrom) {
      show = false;
    }
    if (filterDateTo && date > filterDateTo) {
      show = false;
    }
    
    row.style.display = show ? '' : 'none';
  }
}

// Auto-fetch from cURL command
function autoFetchFromCurl() {
  const input = document.getElementById('betDataInput').value.trim();
  
  if (!input) {
    alert('Please paste your cURL command first');
    return;
  }
  
  if (!input.startsWith('curl ')) {
    alert('‚ùå Please paste the ENTIRE cURL command (should start with "curl")');
    return;
  }
  
  const btn = event.target.closest('button');
  const originalText = btn.innerHTML;
  btn.innerHTML = '<i class="ti ti-loader icon me-2"></i>Fetching ALL your bets...';
  btn.disabled = true;
  
  // Send cURL to server to fetch all bets
  fetch('/api/bets/fetch-from-curl', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ curl: input })
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      alert('‚úÖ ' + data.message);
      window.location.reload();
    } else {
      alert('‚ùå Error: ' + data.message);
    }
  })
  .catch(error => {
    alert('‚ùå Network error: ' + error.message);
  })
  .finally(() => {
    btn.innerHTML = originalText;
    btn.disabled = false;
  });
}

// Auto-fetch bets from BetOnline
function autoFetchBets() {
  const btn = event.target.closest('button');
  const originalText = btn.innerHTML;
  btn.innerHTML = '<i class="ti ti-loader icon me-2"></i>Fetching...';
  btn.disabled = true;
  
  fetch('/api/bets/auto-fetch', {
    method: 'POST'
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      alert('‚úÖ ' + data.message);
      window.location.reload();
    } else {
      alert('‚ùå ' + data.message);
      if (data.need_setup) {
        alert('Run this command first:\n\npython3 setup_betonline_auto_fetch.py');
      }
    }
  })
  .catch(error => {
    alert('‚ùå Network error: ' + error.message);
  })
  .finally(() => {
    btn.innerHTML = originalText;
    btn.disabled = false;
  });
}

// Load bets from pasted BetOnline data
function loadBets() {
  const input = document.getElementById('betDataInput').value.trim();
  
  if (!input) {
    alert('Please paste your bet data first');
    return;
  }
  
  // Parse BetOnline format
  const bets = parseBetOnlineData(input);
  
  if (bets.length === 0) {
    alert('‚ùå Could not parse any bets. Make sure you copied the bet data correctly.');
    return;
  }
  
  // Send to server
  fetch('/api/bets/load', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ bets: bets })
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      alert(`‚úÖ ${data.message}`);
      window.location.reload();
    } else {
      alert('‚ùå Error: ' + data.message);
    }
  })
  .catch(error => {
    alert('‚ùå Network error: ' + error.message);
  });
}

// Parse table format (copied from BetOnline bet history table)
function parseTableFormat(text) {
  const bets = [];
  
  // Split by lines and remove header rows
  const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
  
  // Remove header lines
  const dataLines = lines.filter(l => 
    !l.includes('Ticket #') && 
    !l.includes('Date') && 
    !l.includes('Description') && 
    !l.includes('Type') && 
    !l.includes('Status') && 
    !l.includes('Amount') && 
    !l.includes('To Win')
  );
  
  // Parse bets (each bet is 7 lines: ticket, date, description, type, status, amount, to_win)
  for (let i = 0; i < dataLines.length; i += 7) {
    if (i + 6 >= dataLines.length) break;
    
    const ticketId = dataLines[i].trim();
    const date = dataLines[i + 1].trim();
    const description = dataLines[i + 2].trim();
    const betType = dataLines[i + 3].trim();
    const status = dataLines[i + 4].trim();
    const amountStr = dataLines[i + 5].replace(/\$/g, '').replace(/,/g, '').trim();
    const toWinStr = dataLines[i + 6].replace(/\$/g, '').replace(/,/g, '').trim();
    
    const amount = parseFloat(amountStr) || 0;
    const toWin = parseFloat(toWinStr) || 0;
    
    // Format description based on bet type
    let formattedDesc = description;
    
    if (betType.toLowerCase().includes('parlay') && !betType.toLowerCase().includes('same game')) {
      // Try to parse regular parlay legs from description
      formattedDesc = description; // Keep as-is for now, will be parsed when clicked
    } else if (description.includes('FOOTBALL -') && description.includes('|')) {
      // Same Game Parlay or detailed bet - keep full description
      formattedDesc = description;
    } else if (description.match(/FOOTBALL - \d+/)) {
      // Simple bet like "FOOTBALL - 278 Indianapolis Colts -15 -110"
      // Try to extract team and line
      const match = description.match(/FOOTBALL - \d+\s+(.+?)\s+([-+]?\d+(?:\.5)?)\s+[-+]?\d+/);
      if (match) {
        const team = match[1].trim();
        const line = match[2];
        formattedDesc = `${team} ${line}`;
      }
    }
    
    bets.push({
      ticket_id: ticketId,
      date: date,
      description: formattedDesc,
      bet_type: betType,
      status: status,
      amount: amount,
      to_win: toWin
    });
  }
  
  return bets;
}

// Parse BetOnline pasted data
function parseBetOnlineData(text) {
  const bets = [];
  
  // Check if it's table format (has "Ticket #" header)
  if (text.includes('Ticket #') && text.includes('Date') && text.includes('Description')) {
    return parseTableFormat(text);
  }
  
  // Otherwise, parse detailed format
  // Try to extract ticket number
  const ticketMatch = text.match(/Ticket Number:\s*(\S+)/);
  if (!ticketMatch) {
    console.log('‚ùå No ticket number found');
    return bets;
  }
  
  const ticketNumber = ticketMatch[1];
  console.log('‚úì Ticket:', ticketNumber);
  
  // Extract date
  const dateMatch = text.match(/Accepted Date:\s*(\d{2}\/\d{2}\/\d{2})/);
  const date = dateMatch ? dateMatch[1] : new Date().toLocaleDateString('en-US');
  
  // Extract type (handle multi-word types like "Same Game Parlay")
  const typeMatch = text.match(/Type:\s*(.+?)(?:\n|$)/);
  const betType = typeMatch ? typeMatch[1].trim() : 'Unknown';
  console.log('‚úì Type:', betType);
  
  // Extract amount
  const amountMatch = text.match(/Amount:\s*\$?([\d,]+\.?\d*)/);
  const amount = amountMatch ? parseFloat(amountMatch[1].replace(/,/g, '')) : 0;
  console.log('‚úì Amount:', amount);
  
  // Extract to win
  const toWinMatch = text.match(/To win:\s*\$?([\d,]+\.?\d*)/);
  const toWin = toWinMatch ? parseFloat(toWinMatch[1].replace(/,/g, '')) : 0;
  console.log('‚úì To Win:', toWin);
  
  // Extract status
  const statusMatch = text.match(/Status:\s*(\w+)/);
  const status = statusMatch ? statusMatch[1] : 'Pending';
  console.log('‚úì Status:', status);
  
  // Team name to abbreviation mapping
  const teamMap = {
    'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
    'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
    'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
    'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
    'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
    'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
    'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
    'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
    'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
    'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
    'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
  };
  
  // Extract description (all the legs for parlays)
  let description = '';
  const descMatch = text.match(/Description:\s*(.+)/s);
  console.log('Description match:', descMatch ? 'YES' : 'NO');
  if (descMatch) {
    const rawDesc = descMatch[1];
    console.log('Raw description length:', rawDesc.length);
    
    // For parlays, extract legs
    if (betType.toLowerCase().includes('parlay')) {
      console.log('Parsing as parlay...');
      const legs = [];
      
      // Try format 1: "270 Carolina Panthers +7 -105 For Game" or "281 Green Bay Packers/Pittsburgh Steelers over 46 -110 For Game"
      // Match spreads: "| 279 Dallas Cowboys +3¬Ω -118 For Game"
      const spreadMatches = rawDesc.matchAll(/\|\s*\d+\s+([A-Za-z\s]+?)\s+([-+]\d+(?:¬Ω)?)\s+[-+]?\d+\s+For\s+Game/gi);
      for (const match of spreadMatches) {
        const team = match[1].trim();
        let spread = match[2].replace('¬Ω', '.5');
        const teamAbbr = teamMap[team] || team.split(' ').map(w => w[0]).join('');
        legs.push(`${teamAbbr} ${spread}`);
      }
      
      // Match totals: "| 281 Green Bay Packers/Pittsburgh Steelers over 46 -110 For Game"
      const totalMatches = rawDesc.matchAll(/\|\s*\d+\s+([A-Za-z\s]+?)\/([A-Za-z\s]+?)\s+(over|under)\s+([\d.]+)\s+[-+]?\d+\s+For\s+Game/gi);
      for (const match of totalMatches) {
        const team1 = match[1].trim();
        const team2 = match[2].trim();
        const overUnder = match[3];
        const line = match[4];
        const abbr1 = teamMap[team1] || team1.split(' ').map(w => w[0]).join('');
        const abbr2 = teamMap[team2] || team2.split(' ').map(w => w[0]).join('');
        legs.push(`${abbr1}/${abbr2} ${overUnder} ${line}`);
      }
      
      // Try format 2: "Money line - Colts (Game)" or "Player stats - Daniel Jones over 211.5 Passing yds (Game)"
      if (legs.length === 0) {
        console.log('Trying format 2 (line-by-line)...');
        // Extract each line that looks like a bet leg
        const lines = rawDesc.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        console.log('Found', lines.length, 'lines');
        
        for (const line of lines) {
          console.log('  Processing line:', line);
          // Skip the game header line
          if (line.includes('FOOTBALL - NFL -')) continue;
          
          // Match "Money line - Colts (Game)"
          if (line.match(/Money line - (\w+)/i)) {
            const teamMatch = line.match(/Money line - (\w+)/i);
            if (teamMatch) {
              legs.push(`${teamMatch[1]} ML`);
            }
          }
          // Match "Player stats - Daniel Jones over 211.5 Passing yds (Game)"
          else if (line.match(/Player stats - (.+?) (over|under|[\d+]+) (.+?) \(Game\)/i)) {
            const propMatch = line.match(/Player stats - (.+?) (over|under|[\d+]+) (.+?) \(Game\)/i);
            if (propMatch) {
              const player = propMatch[1].split(' ').map(w => w[0]).join(''); // Initials
              const type = propMatch[2];
              const stat = propMatch[3];
              legs.push(`${player} ${type} ${stat}`);
            }
          }
          // Match "Player TDs - Kayshon Boutte Score anytime (Game)"
          else if (line.match(/Player TDs - (.+?) Score anytime/i)) {
            const tdMatch = line.match(/Player TDs - (.+?) Score anytime/i);
            if (tdMatch) {
              const player = tdMatch[1].split(' ').map(w => w[0]).join('');
              legs.push(`${player} TD`);
            }
          }
          // Match "Spread - Patriots -7.5 (Game)"
          else if (line.match(/Spread - (\w+) ([-+]\d+(?:\.\d+)?)/i)) {
            const spreadMatch = line.match(/Spread - (\w+) ([-+]\d+(?:\.\d+)?)/i);
            if (spreadMatch) {
              legs.push(`${spreadMatch[1]} ${spreadMatch[2]}`);
            }
          }
          // Match "Total points - Over 40.5 (Game)"
          else if (line.match(/Total points - (Over|Under) ([\d.]+)/i)) {
            const totalMatch = line.match(/Total points - (Over|Under) ([\d.]+)/i);
            if (totalMatch) {
              legs.push(`${totalMatch[1]} ${totalMatch[2]}`);
            }
          }
        }
      }
      
      if (legs.length > 0) {
        // Use the FULL raw description if it has leg statuses (Won/Lost/Pending)
        // Otherwise use the shortened format
        if (rawDesc.includes('| Won') || rawDesc.includes('| Lost') || rawDesc.includes('| Pending')) {
          description = rawDesc;
          console.log('‚úì Using full raw description with leg statuses');
        } else {
          description = `${legs.length}-leg ${betType}: ${legs.join(' | ')}`;
          console.log('‚úì Final description:', description);
        }
      } else {
        description = rawDesc.substring(0, 200);
        console.log('‚ö†Ô∏è No legs parsed, using raw description');
      }
    } else {
      description = rawDesc.substring(0, 200);
    }
  }
  
  const bet = {
    ticket_id: ticketNumber,
    date: date,
    description: description,
    bet_type: betType,
    status: status,
    amount: amount,
    to_win: toWin
  };
  
  console.log('‚úì Parsed bet:', bet);
  bets.push(bet);
  
  return bets;
}

// Clear all bets
function clearBets() {
  if (confirm('Are you sure you want to clear all bets?')) {
    fetch('/api/bets/clear', {
      method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        alert('‚úÖ All bets cleared');
        window.location.reload();
      }
    });
  }
}

// Live bet status tracking
let liveStatusInterval = null;

function updateLiveBetStatus() {
  fetch('/api/live-bet-status')
    .then(response => response.json())
    .then(data => {
      // Update each bet row with live status
      Object.entries(data).forEach(([ticketNumber, betStatus]) => {
        const row = document.querySelector(`tr[data-ticket="${ticketNumber}"]`);
        if (row) {
          // Use Tabler's official color classes
          const colorClass = `text-${betStatus.color}`;
          
          // Update row background using Tabler's table-* classes
          row.classList.remove('table-success', 'table-danger', 'table-warning');
          if (betStatus.color === 'success') {
            row.classList.add('table-success');
          } else if (betStatus.color === 'danger') {
            row.classList.add('table-danger');
          } else if (betStatus.color === 'warning') {
            row.classList.add('table-warning');
          }
          
          // Add live indicator badge using Tabler badge component
          const statusCell = row.querySelector('td:nth-child(5)');
          if (statusCell && !statusCell.querySelector('.badge-live')) {
            const badge = document.createElement('span');
            badge.className = `badge badge-live bg-${betStatus.color} badge-pulse ms-2`;
            badge.textContent = 'LIVE';
            badge.title = `${betStatus.game.away_team} ${betStatus.game.away_score} @ ${betStatus.game.home_team} ${betStatus.game.home_score}`;
            statusCell.appendChild(badge);
          }
        }
      });
    })
    .catch(error => {
      console.error('Error fetching live status:', error);
    });
}

// Start live tracking on page load
document.addEventListener('DOMContentLoaded', function() {
  // Add data-ticket attribute to rows for easier lookup
  document.querySelectorAll('#betsTable tbody tr').forEach(row => {
    const ticketCell = row.querySelector('td:first-child small');
    if (ticketCell) {
      row.setAttribute('data-ticket', ticketCell.textContent.trim());
    }
  });
  
  // Update immediately
  updateLiveBetStatus();
  
  // Then update every 30 seconds
  liveStatusInterval = setInterval(updateLiveBetStatus, 30000);
});

// Clean up interval when leaving page
window.addEventListener('beforeunload', function() {
  if (liveStatusInterval) {
    clearInterval(liveStatusInterval);
  }
});
</script>

<!-- Add Tabler badge pulse animation using official CSS custom properties -->
<style>
@keyframes badge-pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.badge-pulse {
  animation: badge-pulse 2s ease-in-out infinite;
}

/* Use Tabler's table row hover states */
#betsTable tbody tr.table-success {
  --tblr-table-bg: var(--tblr-success-lt);
  --tblr-table-hover-bg: var(--tblr-success);
}

#betsTable tbody tr.table-danger {
  --tblr-table-bg: var(--tblr-danger-lt);
  --tblr-table-hover-bg: var(--tblr-danger);
}

#betsTable tbody tr.table-warning {
  --tblr-table-bg: var(--tblr-warning-lt);
  --tblr-table-hover-bg: var(--tblr-warning);
}
</style>
{% endblock %}
