{% extends "base.html" %}

{% block title %}All Games{% endblock %}
{% block page_title %}Week {{ current_week }} Predictions{% endblock %}
{% block page_subtitle %}All games with betting intelligence{% endblock %}

{% block content %}
<!-- Prediction Controls -->
<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-body">
        <div class="row g-3 align-items-end">
          <div class="col-md-3">
            <label class="form-label">Calibration Factor</label>
            <div class="input-group">
              <input type="number" class="form-control" id="calibrationInput" 
                     min="0.1" max="1.5" step="0.01" value="0.54">
              <button class="btn btn-primary" onclick="updateCalibration()">
                <i class="ti ti-check icon"></i>
              </button>
            </div>
            <small class="form-hint">Current: <span id="currentCalibration">0.54</span></small>
          </div>
          <div class="col-md-3">
            <select class="form-select" id="predictionHistorySelect">
              <option value="">Current Week</option>
            </select>
          </div>
          <div class="col-md-3">
            <button class="btn btn-success w-100" onclick="generatePredictions()" id="generateBtn">
              <i class="ti ti-refresh icon"></i>
              Generate Next Week
            </button>
          </div>
          <div class="col-md-3">
            <div class="text-muted small">
              <strong>Model:</strong> XGBoost + EPA<br>
              <strong>Accuracy:</strong> 18.7% improved
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Stats cards -->
<div class="row row-deck row-cards mb-3">
  <div class="col-sm-6 col-lg-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <div class="subheader">Total Games</div>
        </div>
        <div class="h1 mb-3" id="stat-total-games">{{ total_games }}</div>
        <div class="d-flex mb-2">
          <div>Games analyzed this week</div>
        </div>
      </div>
    </div>
  </div>
  <div class="col-sm-6 col-lg-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <div class="subheader">Recommended Plays</div>
        </div>
        <div class="h1 mb-3" id="stat-rec-plays">{{ rec_plays }}</div>
        <div class="d-flex mb-2">
          <div>Bets with positive EV</div>
        </div>
      </div>
    </div>
  </div>
  <div class="col-sm-6 col-lg-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <div class="subheader">Average Edge</div>
        </div>
        <div class="h1 mb-3" id="stat-avg-edge">{{ "%.1f"|format(avg_edge) }}%</div>
        <div class="d-flex mb-2">
          <div>Expected value vs market</div>
        </div>
      </div>
    </div>
  </div>
  <div class="col-sm-6 col-lg-3">
    <div class="card">
      <div class="card-body">
        <div class="d-flex align-items-center">
          <div class="subheader">Total Stake</div>
        </div>
        <div class="h1 mb-3" id="stat-total-stake">${{ "%.0f"|format(total_stake) }}</div>
        <div class="d-flex mb-2">
          <div>Recommended total exposure</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Best Bets -->
<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <h3 class="card-title">üí∞ Best Bets</h3>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-vcenter card-table" id="best-bets-table">
            <thead>
              <tr>
                <th>Game</th>
                <th>Type</th>
                <th>Recommendation</th>
                <th class="text-end">EV</th>
                <th class="text-end">Stake</th>
                <th class="text-end">Win %</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="6" class="text-center text-muted">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- All Games -->
<div class="row">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        <h3 class="card-title">üìä All Games</h3>
        <div class="ms-auto">
          <span class="text-muted small">
            <i class="ti ti-click icon"></i>
            Click any game for detailed stats
          </span>
        </div>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-vcenter table-hover card-table" id="all-games-table">
            <thead>
              <tr>
                <th>Away</th>
                <th>Home</th>
                <th>Scores (Market ‚Üí Adjusted)</th>
                <th>Signals & Best Bet</th>
                <th class="text-end">Market Spread</th>
                <th class="text-end">Adjusted Spread</th>
                <th>Spread Rec</th>
                <th class="text-end">Market Total</th>
                <th class="text-end">Adjusted Total</th>
                <th>Total Rec</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="10" class="text-center text-muted">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="card-footer">
          <small class="text-muted">
            <span class="text-info">‚óè</span> Market lines from Odds API &nbsp;&nbsp;
            <span class="text-primary">‚óè</span> Adjusted lines show our edge (when different from market)
          </small>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Load best bets
fetch('/api/best-bets')
  .then(response => response.json())
  .then(data => {
    const tbody = document.querySelector('#best-bets-table tbody');
    tbody.innerHTML = '';
    
    if (data.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted">No recommended bets this week</td></tr>';
      return;
    }
    
    data.forEach(bet => {
      const row = document.createElement('tr');
      
      // Badge color based on edge points
      let badgeClass = 'badge-success';
      if (bet.edge_pts > 5) badgeClass = 'badge-danger';
      else if (bet.edge_pts > 3) badgeClass = 'badge-warning';
      
      row.innerHTML = `
        <td><strong>${bet.game}</strong></td>
        <td><span class="badge badge-outline text-primary">${bet.type}</span></td>
        <td>${bet.recommendation}</td>
        <td class="text-end"><span class="badge ${badgeClass}">${bet.edge_pts.toFixed(1)} pts</span></td>
        <td class="text-end"><strong>$${bet.stake.toFixed(0)}</strong></td>
        <td class="text-end">-</td>
      `;
      tbody.appendChild(row);
    });
  })
  .catch(error => {
    console.error('Error loading best bets:', error);
    document.querySelector('#best-bets-table tbody').innerHTML = 
      '<tr><td colspan="6" class="text-center text-danger">Error loading data</td></tr>';
  });

// Load all games
fetch('/api/games')
  .then(response => response.json())
  .then(data => {
    const tbody = document.querySelector('#all-games-table tbody');
    tbody.innerHTML = '';
    
    data.forEach(game => {
      const row = document.createElement('tr');
      row.style.cursor = 'pointer';
      
      // Add click handler to go to detail page
      row.addEventListener('click', () => {
        window.location.href = `/game/${game.away}/${game.home}`;
      });
      
      // Add hover effect
      row.addEventListener('mouseenter', () => {
        row.classList.add('table-active');
      });
      row.addEventListener('mouseleave', () => {
        row.classList.remove('table-active');
      });
      
      // Format spread with +/- sign
      const marketSpreadFormatted = game.market_spread > 0 ? `+${game.market_spread.toFixed(1)}` : game.market_spread.toFixed(1);
      const adjustedSpreadFormatted = game.adjusted_spread > 0 ? `+${game.adjusted_spread.toFixed(1)}` : game.adjusted_spread.toFixed(1);
      
      // Check if adjusted differs from market (has edge)
      const hasSpreadEdge = Math.abs(game.adjusted_spread - game.market_spread) >= 0.5;
      const hasTotalEdge = Math.abs(game.adjusted_total - game.market_total) >= 0.5;
      
      const adjustedSpreadClass = hasSpreadEdge ? 'text-primary fw-bold' : 'text-muted';
      const adjustedTotalClass = hasTotalEdge ? 'text-primary fw-bold' : 'text-muted';
      
      // Edge Hunt signals
      let edgeHuntBadges = '';
      if (game.has_edge_hunt_signal && game.edge_hunt_signals && game.edge_hunt_signals.length > 0) {
        game.edge_hunt_signals.forEach(signal => {
          const badgeClass = signal.badge_color === 'danger' ? 'bg-danger' :
                            signal.badge_color === 'warning' ? 'bg-warning' :
                            signal.badge_color === 'info' ? 'bg-info' : 'bg-primary';
          
          // Create tooltip with explanation
          const tooltip = signal.explanation.replace(/"/g, '&quot;');
          const details = signal.details.join('<br>').replace(/"/g, '&quot;');
          
          edgeHuntBadges += `<span class="badge ${badgeClass} ms-1" 
                                   data-bs-toggle="tooltip" 
                                   data-bs-html="true"
                                   data-bs-placement="top"
                                   title="<strong>${signal.icon} ${signal.badge}</strong><br><br>${tooltip}<br><br><small>${details}</small>">
                               ${signal.icon} ${signal.badge} (+${signal.edge_pts.toFixed(1)})
                             </span>`;
        });
      }
      
      // Format scores - Market ‚Üí Adjusted (if different)
      // Show one decimal place to match spread precision
      const marketImpliedScore = `${game.market_implied_away.toFixed(1)}-${game.market_implied_home.toFixed(1)}`;
      const adjustedScore = `${game.adjusted_away.toFixed(1)}-${game.adjusted_home.toFixed(1)}`;
      const hasScoreAdjustment = Math.abs(game.adjusted_away - game.market_implied_away) >= 0.1 || Math.abs(game.adjusted_home - game.market_implied_home) >= 0.1;
      
      // Show Market and Adjusted scores
      const scoreDisplay = `
        <div class="small">
          <div><strong>Market:</strong> <span class="text-info">${marketImpliedScore}</span></div>
          ${hasScoreAdjustment ? `<div><strong>Adjusted:</strong> <span class="text-primary fw-bold">${adjustedScore}</span></div>` : ''}
        </div>
      `;
      
      // Best bet display
      const bestBetDisplay = game.rec_spread !== 'SKIP' || game.rec_total !== 'SKIP' ?
        `<span class="badge bg-success">${game.rec_spread !== 'SKIP' ? game.rec_spread.substring(0, 30) : game.rec_total.substring(0, 30)}</span>` :
        `<span class="badge badge-outline text-muted">NO PLAY</span>`;
      
      row.innerHTML = `
        <td><strong>${game.away}</strong></td>
        <td><strong>${game.home}</strong></td>
        <td>${scoreDisplay}</td>
        <td>
          ${edgeHuntBadges}
          ${bestBetDisplay}
        </td>
        <td class="text-end text-info">${marketSpreadFormatted}</td>
        <td class="text-end ${adjustedSpreadClass}">${adjustedSpreadFormatted}</td>
        <td><small>${game.rec_spread.substring(0, 30)}</small></td>
        <td class="text-end text-info">${game.market_total.toFixed(1)}</td>
        <td class="text-end ${adjustedTotalClass}">${game.adjusted_total.toFixed(1)}</td>
        <td><small>${game.rec_total.substring(0, 30)}</small></td>
      `;
      tbody.appendChild(row);
    });
    
    // Initialize Bootstrap tooltips for Edge Hunt signals
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
  })
  .catch(error => {
    console.error('Error loading games:', error);
    document.querySelector('#all-games-table tbody').innerHTML = 
      '<tr><td colspan="10" class="text-center text-danger">Error loading data</td></tr>';
  });

// Live game status tracking - colors ALL games based on live scores
let liveStatusInterval = null;

function updateLiveGameStatus() {
  fetch('/api/live-games')
    .then(response => response.json())
    .then(liveGames => {
      // Update all-games table with live scores and colors
      const allGamesRows = document.querySelectorAll('#all-games-table tbody tr');
      
      allGamesRows.forEach(row => {
        const awayTeam = row.querySelector('td:first-child')?.textContent.trim();
        const homeTeam = row.querySelector('td:nth-child(2)')?.textContent.trim();
        
        // Find matching live game using abbreviations
        const liveGame = liveGames.find(g => 
          g.away_abbr === awayTeam && g.home_abbr === homeTeam
        );
        
        if (liveGame) {
          // Remove old colors
          row.classList.remove('table-success', 'table-danger', 'table-warning', 'table-info');
          
          // Color based on recommendation status
          if (liveGame.best_status === 'winning') {
            row.classList.add('table-success');
          } else if (liveGame.best_status === 'losing') {
            row.classList.add('table-danger');
          } else if (liveGame.best_status === 'neutral') {
            row.classList.add('table-warning');
          } else {
            row.classList.add('table-info'); // Game is live but no clear status
          }
          
          // Add LIVE badge with current score
          const scoreCell = row.querySelector('td:nth-child(3)');
          if (scoreCell) {
            // Remove old badge if exists
            const oldBadge = scoreCell.querySelector('.badge-live');
            if (oldBadge) oldBadge.remove();
            
            const badge = document.createElement('span');
            badge.className = 'badge badge-live bg-info badge-pulse ms-2';
            badge.textContent = 'LIVE';
            badge.title = `${liveGame.away_team} ${liveGame.away_score} @ ${liveGame.home_team} ${liveGame.home_score} - ${liveGame.status}`;
            scoreCell.appendChild(badge);
            
            // Update score display
            const currentScore = ` (${liveGame.away_score}-${liveGame.home_score})`;
            if (!scoreCell.textContent.includes(currentScore)) {
              const textNode = scoreCell.childNodes[0];
              if (textNode) {
                textNode.textContent = textNode.textContent.split('(')[0].trim() + currentScore;
              }
            }
          }
        }
      });
      
      // Update best bets table too
      const bestBetsRows = document.querySelectorAll('#best-bets-table tbody tr');
      bestBetsRows.forEach(row => {
        const gameText = row.querySelector('td:first-child')?.textContent.trim();
        
        // Find matching live game using abbreviations (gameText is like "MIN @ LAC")
        const liveGame = liveGames.find(g => 
          gameText.includes(g.away_abbr) && gameText.includes(g.home_abbr)
        );
        
        if (liveGame) {
          // Remove old colors
          row.classList.remove('table-success', 'table-danger', 'table-warning');
          
          // Color based on recommendation status
          if (liveGame.best_status === 'winning') {
            row.classList.add('table-success');
          } else if (liveGame.best_status === 'losing') {
            row.classList.add('table-danger');
          } else if (liveGame.best_status === 'neutral') {
            row.classList.add('table-warning');
          }
          
          // Add LIVE badge
          const gameCell = row.querySelector('td:first-child');
          if (gameCell && !gameCell.querySelector('.badge-live')) {
            const badge = document.createElement('span');
            badge.className = 'badge badge-live bg-info badge-pulse ms-2';
            badge.textContent = 'LIVE';
            badge.title = `${liveGame.away_team} ${liveGame.away_score} @ ${liveGame.home_team} ${liveGame.home_score}`;
            gameCell.appendChild(badge);
          }
        }
      });
    })
    .catch(error => {
      console.error('Error fetching live games:', error);
    });
}

// Start live tracking on page load
document.addEventListener('DOMContentLoaded', function() {
  // Wait for tables to be populated first
  setTimeout(() => {
    // Update immediately
    updateLiveGameStatus();
    
    // Then update every 30 seconds
    liveStatusInterval = setInterval(updateLiveGameStatus, 30000);
  }, 2000); // Wait 2 seconds for initial data load
});

// Clean up interval when leaving page
window.addEventListener('beforeunload', function() {
  if (liveStatusInterval) {
    clearInterval(liveStatusInterval);
  }
});

// Load prediction history on page load
async function loadPredictionHistory() {
  try {
    const response = await fetch('/api/predictions/history');
    const data = await response.json();
    
    if (data.success && data.predictions) {
      const select = document.getElementById('predictionHistorySelect');
      
      // Add historical predictions to dropdown
      data.predictions.forEach(pred => {
        const option = document.createElement('option');
        option.value = pred.filename;
        option.textContent = pred.date;
        select.appendChild(option);
      });
      
      // Handle selection change
      select.addEventListener('change', async function() {
        if (this.value) {
          await loadHistoricalPredictions(this.value);
        } else {
          // Reload current page
          window.location.reload();
        }
      });
    }
  } catch (error) {
    console.error('Error loading prediction history:', error);
  }
}

async function loadHistoricalPredictions(filename) {
  try {
    const response = await fetch(`/api/predictions/${filename}`);
    const data = await response.json();
    
    if (data.success) {
      // Update page title
      document.querySelector('.page-title').textContent = `Predictions - ${data.date}`;
      
      // Update tables with historical data
      updateTablesWithPredictions(data.predictions);
    }
  } catch (error) {
    console.error('Error loading historical predictions:', error);
    alert('Failed to load historical predictions');
  }
}

function updateTablesWithPredictions(predictions) {
  // Update best bets table
  const bestBetsTable = document.getElementById('best-bets-table').querySelector('tbody');
  bestBetsTable.innerHTML = '';
  
  // Update all games table  
  const allGamesTable = document.getElementById('all-games-table').querySelector('tbody');
  allGamesTable.innerHTML = '';
  
  predictions.forEach(pred => {
    // Add to all games table
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${pred.away} @ ${pred.home}</td>
      <td>${pred.exp_score}</td>
      <td class="text-end">${pred.model_spread.toFixed(1)}</td>
      <td class="text-end">${pred.spread_used.toFixed(1)}</td>
      <td class="text-end">${pred.home_cover_pct.toFixed(1)}%</td>
      <td class="text-end">${pred.over_pct.toFixed(1)}%</td>
      <td><span class="badge">${pred.best_bet || '-'}</span></td>
      <td class="text-end">${pred.kelly_pct ? pred.kelly_pct.toFixed(1) + '%' : '-'}</td>
      <td class="text-end">${pred.ev ? (pred.ev * 100).toFixed(1) + '%' : '-'}</td>
    `;
    allGamesTable.appendChild(row);
    
    // Add to best bets if has positive EV
    if (pred.ev && pred.ev > 0) {
      const bestRow = row.cloneNode(true);
      bestBetsTable.appendChild(bestRow);
    }
  });
}

async function updateCalibration() {
  const input = document.getElementById('calibrationInput');
  const newCalibration = parseFloat(input.value);
  
  if (newCalibration < 0.1 || newCalibration > 1.5) {
    alert('Calibration must be between 0.1 and 1.5');
    return;
  }
  
  if (!confirm(`Update calibration to ${newCalibration} and regenerate predictions?`)) {
    return;
  }
  
  const btn = input.nextElementSibling;
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
  
  try {
    const response = await fetch('/api/config/calibration', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        calibration: newCalibration,
        regenerate: true
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      document.getElementById('currentCalibration').textContent = newCalibration.toFixed(2);
      alert(`‚úÖ ${data.message}\n\nReloading page...`);
      window.location.reload();
    } else {
      alert(`‚ùå ${data.message}`);
    }
  } catch (error) {
    alert(`‚ùå Error: ${error.message}`);
  } finally {
    btn.disabled = false;
    btn.innerHTML = '<i class="ti ti-check icon"></i>';
  }
}

async function loadCurrentCalibration() {
  try {
    const response = await fetch('/api/config/calibration');
    const data = await response.json();
    
    if (data.success) {
      document.getElementById('calibrationInput').value = data.calibration;
      document.getElementById('currentCalibration').textContent = data.calibration.toFixed(2);
    }
  } catch (error) {
    console.error('Failed to load calibration:', error);
  }
}

async function generatePredictions() {
  const btn = document.getElementById('generateBtn');
  const originalText = btn.innerHTML;
  
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Generating...';
  
  try {
    const response = await fetch('/api/generate-predictions', {
      method: 'POST'
    });
    
    const data = await response.json();
    
    if (data.success) {
      alert(`‚úÖ ${data.message}\n\nFile: ${data.file}\n\nReloading page...`);
      window.location.reload();
    } else {
      alert(`‚ùå ${data.message}\n\n${data.error || ''}`);
    }
  } catch (error) {
    alert(`‚ùå Error: ${error.message}`);
  } finally {
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
}

// Load history and calibration on page load
document.addEventListener('DOMContentLoaded', function() {
  loadCurrentCalibration();
  loadPredictionHistory();
});
</script>

<!-- Add Tabler badge pulse animation using official CSS custom properties -->
<style>
@keyframes badge-pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.badge-pulse {
  animation: badge-pulse 2s ease-in-out infinite;
}

/* Use Tabler's table row hover states */
#best-bets-table tbody tr.table-success,
#all-games-table tbody tr.table-success {
  --tblr-table-bg: var(--tblr-success-lt);
  --tblr-table-hover-bg: var(--tblr-success);
}

#best-bets-table tbody tr.table-danger,
#all-games-table tbody tr.table-danger {
  --tblr-table-bg: var(--tblr-danger-lt);
  --tblr-table-hover-bg: var(--tblr-danger);
}

#best-bets-table tbody tr.table-warning,
#all-games-table tbody tr.table-warning {
  --tblr-table-bg: var(--tblr-warning-lt);
  --tblr-table-hover-bg: var(--tblr-warning);
}

#all-games-table tbody tr.table-info {
  --tblr-table-bg: var(--tblr-info-lt);
  --tblr-table-hover-bg: var(--tblr-info);
}
</style>
{% endblock %}

